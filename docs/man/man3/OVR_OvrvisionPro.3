.TH "OVR::OvrvisionPro" 3 "Tue Dec 29 2015" "Version 1.3" "OvrvisionSDK" \" -*- nroff -*-
.ad l
.nh
.SH NAME
OVR::OvrvisionPro \- \fBOvrvisionPro\fP class\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <ovrvision_pro\&.h>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBOvrvisionPro\fP ()"
.br
.RI "\fIConstructor\&. \fP"
.ti -1c
.RI "\fB~OvrvisionPro\fP ()"
.br
.RI "\fIDestructor\&. \fP"
.ti -1c
.RI "int \fBOpen\fP (int locationID, OVR::Camprop prop, int deviceType=\-1, void *pD3D11Device=NULL)"
.br
.RI "\fIOpen the Ovrvision Pro\&. \fP"
.ti -1c
.RI "void \fBClose\fP ()"
.br
.RI "\fIClose the Ovrvision Pro\&. \fP"
.ti -1c
.RI "void \fBPreStoreCamData\fP (OVR::Camqt qt)"
.br
.RI "\fIThis function gets data from \fBOvrvisionPro\fP inside\&. \fP"
.ti -1c
.RI "unsigned char * \fBGetCamImageBGRA\fP (OVR::Cameye eye)"
.br
.RI "\fIGets the image data of 32 bits of BGRA form\&. \fP"
.ti -1c
.RI "void \fBGetCamImageBGRA\fP (unsigned char *pImageBuf, OVR::Cameye eye)"
.br
.RI "\fIThis function gets data from \fBOvrvisionPro\fP inside\&. \fP"
.ti -1c
.RI "void \fBGetStereoImageBGRA\fP (unsigned char *pLeft, unsigned char *pRight, \fBROI\fP roi)"
.br
.RI "\fIGet camera image region of interest\&. \fP"
.ti -1c
.RI "bool \fBisOpen\fP ()"
.br
.RI "\fICheck whether \fBOvrvisionPro\fP is open\&. \fP"
.ti -1c
.RI "int \fBGetCamWidth\fP ()"
.br
.RI "\fIGet the width of the Ovrvision image\&. \fP"
.ti -1c
.RI "int \fBGetCamHeight\fP ()"
.br
.RI "\fIGet the height of the Ovrvision image\&. \fP"
.ti -1c
.RI "int \fBGetCamFramerate\fP ()"
.br
.RI "\fIGet the framerate of the Ovrvision\&. \fP"
.ti -1c
.RI "float \fBGetCamFocalPoint\fP ()"
.br
.RI "\fIGet the focal point of the Ovrvision image\&. \fP"
.ti -1c
.RI "float \fBGetHMDRightGap\fP (int at)"
.br
.RI "\fIGet the gap between images for HMD\&. \fP"
.ti -1c
.RI "int \fBGetCamBuffersize\fP ()"
.br
.RI "\fIGet the buffer size of the Ovrvision image\&. \fP"
.ti -1c
.RI "int \fBGetCamPixelsize\fP ()"
.br
.RI "\fIGet the pixel data size\&. default is BGRA 4 byte\&. \fP"
.ti -1c
.RI "int \fBGetCameraExposure\fP ()"
.br
.RI "\fIGet exposure value of the Ovrvision\&. \fP"
.ti -1c
.RI "void \fBSetCameraExposure\fP (int value)"
.br
.RI "\fISet exposure of the Ovrvision\&. \fP"
.ti -1c
.RI "int \fBGetCameraGain\fP ()"
.br
.RI "\fIGet gain value of the Ovrvision\&. \fP"
.ti -1c
.RI "void \fBSetCameraGain\fP (int value)"
.br
.RI "\fISet gain of the Ovrvision\&. \fP"
.ti -1c
.RI "int \fBGetCameraWhiteBalanceR\fP ()"
.br
.RI "\fIGet white balance R gain value of the Ovrvision\&. \fP"
.ti -1c
.RI "void \fBSetCameraWhiteBalanceR\fP (int value)"
.br
.RI "\fISet white balance R gain of the Ovrvision\&. \fP"
.ti -1c
.RI "int \fBGetCameraWhiteBalanceG\fP ()"
.br
.RI "\fIGet white balance G gain value of the Ovrvision\&. \fP"
.ti -1c
.RI "void \fBSetCameraWhiteBalanceG\fP (int value)"
.br
.RI "\fISet white balance G gain of the Ovrvision\&. \fP"
.ti -1c
.RI "int \fBGetCameraWhiteBalanceB\fP ()"
.br
.RI "\fIGet white balance B gain value of the Ovrvision\&. \fP"
.ti -1c
.RI "void \fBSetCameraWhiteBalanceB\fP (int value)"
.br
.RI "\fISet white balance B gain of the Ovrvision\&. \fP"
.ti -1c
.RI "int \fBGetCameraBLC\fP ()"
.br
.RI "\fISet backlight compensation(BLC) value of the Ovrvision\&. \fP"
.ti -1c
.RI "void \fBSetCameraBLC\fP (int value)"
.br
.RI "\fISet backlight compensation(BLC) of the Ovrvision\&. \fP"
.ti -1c
.RI "bool \fBGetCameraWhiteBalanceAuto\fP ()"
.br
.RI "\fIGet automatic mode of the Ovrvision White Balance\&. \fP"
.ti -1c
.RI "void \fBSetCameraWhiteBalanceAuto\fP (bool value)"
.br
.RI "\fISet automatic mode of the Ovrvision White Balance\&. \fP"
.ti -1c
.RI "void \fBSetCameraSyncMode\fP (bool value)"
.br
.RI "\fISet sync mode for the Ovrvision\&. \fP"
.ti -1c
.RI "int \fBOpenCLExtensions\fP (int(*callback)(void *, const char *), void *item)"
.br
.RI "\fIGet OpenCL extensions of GPU\&. \fP"
.ti -1c
.RI "void \fBGrayscaleHalf\fP (unsigned char *left, unsigned char *right)"
.br
.RI "\fIGrayscaled image of 1/2 scaled\&. \fP"
.ti -1c
.RI "void \fBGrayscaleFourth\fP (unsigned char *left, unsigned char *right)"
.br
.RI "\fIGrayscaled image of 1/4 scaled\&. \fP"
.ti -1c
.RI "void \fBGrayscaleEighth\fP (unsigned char *left, unsigned char *right)"
.br
.RI "\fIGrayscaled image of 1/8 scaled\&. \fP"
.ti -1c
.RI "void \fBUserDataAccessUnlock\fP ()"
.br
.ti -1c
.RI "void \fBUserDataAccessLock\fP ()"
.br
.ti -1c
.RI "void \fBUserDataAccessSelectAddress\fP (unsigned int addr)"
.br
.ti -1c
.RI "unsigned char \fBUserDataAccessGetData\fP ()"
.br
.ti -1c
.RI "void \fBUserDataAccessSetData\fP (unsigned char value)"
.br
.ti -1c
.RI "void \fBUserDataAccessSave\fP ()"
.br
.ti -1c
.RI "void \fBUserDataAccessCheckSumAddress\fP ()"
.br
.ti -1c
.RI "bool \fBCameraParamSaveEEPROM\fP ()"
.br
.ti -1c
.RI "bool \fBCameraParamResetEEPROM\fP ()"
.br
.ti -1c
.RI "void \fBCreateSkinTextures\fP (int width, int height, unsigned int left, unsigned int right)"
.br
.RI "\fICreate Skin textures\&. \fP"
.ti -1c
.RI "void \fBCapture\fP (OVR::Camqt qt)"
.br
.RI "\fICapture frame and hold it in GPU for image processing(Grayscale, Skin color extraction etc\&.) \fP"
.ti -1c
.RI "void \fBUpdateSkinTextures\fP (unsigned int left, unsigned int right)"
.br
.RI "\fIUpdate skin textures\&. \fP"
.ti -1c
.RI "void \fBUpdateImageTextures\fP (unsigned int left, unsigned int right)"
.br
.ti -1c
.RI "\fBROI\fP \fBSetSkinScale\fP (unsigned int scale)"
.br
.RI "\fISet Skin image scale\&. \fP"
.ti -1c
.RI "bool \fBGetScaledImageRGBA\fP (unsigned char *left, unsigned char *right)"
.br
.RI "\fIGet scaled images while calibration\&. \fP"
.ti -1c
.RI "void \fBGetSkinImage\fP (unsigned char *pLeft, unsigned char *pRight)"
.br
.RI "\fIGet Skin images\&. \fP"
.ti -1c
.RI "void \fBDetectHand\fP (int frames)"
.br
.RI "\fIDetect color range\&. \fP"
.ti -1c
.RI "int \fBSkinRegion\fP (unsigned char *left, unsigned char *right)"
.br
.RI "\fIGet skin color region\&. \fP"
.ti -1c
.RI "void \fBSetSkinHSV\fP (int h_low, int h_high, int s_low, int s_high)"
.br
.RI "\fIset HSV region for SkinRegion \fP"
.ti -1c
.RI "void \fBSetSkinHSV\fP (int range[4])"
.br
.RI "\fIset HSV region for SkinRegion \fP"
.ti -1c
.RI "int \fBSetSkinThreshold\fP (int threshold)"
.br
.RI "\fIset skin threshold to extract region \fP"
.ti -1c
.RI "int \fBColorHistgram\fP (unsigned char *histgram)"
.br
.RI "\fIGet color histgram in HSV space\&. \fP"
.ti -1c
.RI "void \fBGetStereoImageHSV\fP (unsigned char *pLeft, unsigned char *pRight)"
.br
.RI "\fIUNDER CONSTRUCTION\&. \fP"
.ti -1c
.RI "void \fBInspectTextures\fP (unsigned char *left, unsigned char *right, unsigned int type=0)"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static bool \fBCheckGPU\fP ()"
.br
.RI "\fICheck GPU specification\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
\fBOvrvisionPro\fP class\&. 
.SH "Member Function Documentation"
.PP 
.SS "void OVR::OvrvisionPro::Capture (OVR::Camqt qt)"

.PP
Capture frame and hold it in GPU for image processing(Grayscale, Skin color extraction etc\&.) 
.PP
\fBParameters:\fP
.RS 4
\fIqt\fP Set an image processing method\&. 
.RE
.PP

.SS "static bool OVR::OvrvisionPro::CheckGPU ()\fC [static]\fP"

.PP
Check GPU specification\&. 
.PP
\fBReturns:\fP
.RS 4
true if satisfaied for OrvisionPro 
.RE
.PP

.SS "int OVR::OvrvisionPro::ColorHistgram (unsigned char * histgram)"

.PP
Get color histgram in HSV space\&. 
.PP
\fBParameters:\fP
.RS 4
\fIHSV\fP histgram (256S x 180H) 
.RE
.PP
\fBReturns:\fP
.RS 4
scale (2, 4) 
.RE
.PP

.SS "void OVR::OvrvisionPro::CreateSkinTextures (int width, int height, unsigned int left, unsigned int right)"

.PP
Create Skin textures\&. 
.PP
\fBParameters:\fP
.RS 4
\fIwidth\fP of texture 
.br
\fIheight\fP of texture 
.br
\fIleft\fP texture 
.br
\fIright\fP texure
.RE
.PP
/////////////////////////////////////////////////////////////////////////////////// How to Create GPU texture and Update texture
.PP
Set scale 1/2 and get its size \fBOVR::ROI\fP size = ovrvision\&.SetSkinScale(2);
.PP
D3D11_TEXTURE2D_DESC desc = { size\&.width, // Width size\&.height, // Height 1, // MipLevels 1, // ArraySize DXGI_FORMAT_R8G8B8A8_UINT, // Format, BE CAREFUL { 1 }, // SampleDesc\&.Count D3D11_USAGE_DEFAULT, // Usage };
.PP
Create Textures ID3D11Texture2D *pTextures[2]; res = DIRECTX\&.Device->CreateTexture2D(&desc, NULL, &pTextures[0]); res = DIRECTX\&.Device->CreateTexture2D(&desc, NULL, &pTextures[1]);
.PP
Create GPU sharing textures ovrvision\&.CreateSkinTextures(size\&.width, size\&.height, pTextures[0], pTextures[1]); /////////////////////////////////////////////////////////////////////////////////// 
.SS "void OVR::OvrvisionPro::DetectHand (int frames)"

.PP
Detect color range\&. 
.PP
\fBParameters:\fP
.RS 4
\fIframes\fP sampling frame 
.RE
.PP

.SS "int OVR::OvrvisionPro::GetCamBuffersize ()"

.PP
Get the buffer size of the Ovrvision image\&. 
.PP
\fBReturns:\fP
.RS 4
size 
.RE
.PP

.SS "int OVR::OvrvisionPro::GetCameraBLC ()"

.PP
Set backlight compensation(BLC) value of the Ovrvision\&. 
.PP
\fBReturns:\fP
.RS 4
blc value\&. 
.RE
.PP

.SS "int OVR::OvrvisionPro::GetCameraExposure ()"

.PP
Get exposure value of the Ovrvision\&. 
.PP
\fBReturns:\fP
.RS 4
Exposure time\&. 
.RE
.PP

.SS "int OVR::OvrvisionPro::GetCameraGain ()"

.PP
Get gain value of the Ovrvision\&. 
.PP
\fBReturns:\fP
.RS 4
gain value\&. 
.RE
.PP

.SS "bool OVR::OvrvisionPro::GetCameraWhiteBalanceAuto ()"

.PP
Get automatic mode of the Ovrvision White Balance\&. 
.PP
\fBReturns:\fP
.RS 4
It is true or false\&. 
.RE
.PP

.SS "int OVR::OvrvisionPro::GetCameraWhiteBalanceB ()"

.PP
Get white balance B gain value of the Ovrvision\&. 
.PP
\fBReturns:\fP
.RS 4
B gain value\&. 
.RE
.PP

.SS "int OVR::OvrvisionPro::GetCameraWhiteBalanceG ()"

.PP
Get white balance G gain value of the Ovrvision\&. 
.PP
\fBReturns:\fP
.RS 4
G gain value\&. 
.RE
.PP

.SS "int OVR::OvrvisionPro::GetCameraWhiteBalanceR ()"

.PP
Get white balance R gain value of the Ovrvision\&. 
.PP
\fBReturns:\fP
.RS 4
R gain value\&. 
.RE
.PP

.SS "float OVR::OvrvisionPro::GetCamFocalPoint ()"

.PP
Get the focal point of the Ovrvision image\&. 
.PP
\fBReturns:\fP
.RS 4
focal point 
.RE
.PP

.SS "int OVR::OvrvisionPro::GetCamFramerate ()"

.PP
Get the framerate of the Ovrvision\&. 
.PP
\fBReturns:\fP
.RS 4
fps 
.RE
.PP

.SS "int OVR::OvrvisionPro::GetCamHeight ()"

.PP
Get the height of the Ovrvision image\&. 
.PP
\fBReturns:\fP
.RS 4
pixel size\&. 
.RE
.PP

.SS "unsigned char* OVR::OvrvisionPro::GetCamImageBGRA (OVR::Cameye eye)"

.PP
Gets the image data of 32 bits of BGRA form\&. 
.PP
\fBParameters:\fP
.RS 4
\fIeye\fP OV_CAMEYE_LEFT or OV_CAMEYE_RIGHT 
.RE
.PP

.SS "void OVR::OvrvisionPro::GetCamImageBGRA (unsigned char * pImageBuf, OVR::Cameye eye)"

.PP
This function gets data from \fBOvrvisionPro\fP inside\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpImageBuf\fP Image buffer pointer 
.br
\fIeye\fP OV_CAMEYE_LEFT or OV_CAMEYE_RIGHT 
.RE
.PP

.SS "int OVR::OvrvisionPro::GetCamPixelsize ()"

.PP
Get the pixel data size\&. default is BGRA 4 byte\&. 
.PP
\fBReturns:\fP
.RS 4
size 
.RE
.PP

.SS "int OVR::OvrvisionPro::GetCamWidth ()"

.PP
Get the width of the Ovrvision image\&. 
.PP
\fBReturns:\fP
.RS 4
pixel size\&. 
.RE
.PP

.SS "float OVR::OvrvisionPro::GetHMDRightGap (int at)"

.PP
Get the gap between images for HMD\&. 
.PP
\fBReturns:\fP
.RS 4
value 
.RE
.PP

.SS "bool OVR::OvrvisionPro::GetScaledImageRGBA (unsigned char * left, unsigned char * right)"

.PP
Get scaled images while calibration\&. 
.PP
\fBParameters:\fP
.RS 4
\fIleft\fP ptr to buffer 
.br
\fIright\fP ptr to buffer 
.RE
.PP
\fBReturns:\fP
.RS 4
true when calibration done 
.RE
.PP

.SS "void OVR::OvrvisionPro::GetSkinImage (unsigned char * pLeft, unsigned char * pRight)"

.PP
Get Skin images\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpLeft\fP Image buffer pointer (RGBA IMAGE) 
.br
\fIpRight\fP Image buffer pointer (RGBA IMAGE) 
.RE
.PP

.SS "void OVR::OvrvisionPro::GetStereoImageBGRA (unsigned char * pLeft, unsigned char * pRight, \fBROI\fP roi)"

.PP
Get camera image region of interest\&. 
.PP
\fBParameters:\fP
.RS 4
\fIpLeft\fP Image buffer pointer for left eye 
.br
\fIpRight\fP Image buffer pointer for right eye 
.br
\fIroi\fP \fBROI\fP 
.RE
.PP

.SS "bool OVR::OvrvisionPro::isOpen ()"

.PP
Check whether \fBOvrvisionPro\fP is open\&. 
.PP
\fBReturns:\fP
.RS 4
If open, It is true 
.RE
.PP

.SS "int OVR::OvrvisionPro::Open (int locationID, OVR::Camprop prop, int deviceType = \fC\-1\fP, void * pD3D11Device = \fCNULL\fP)"

.PP
Open the Ovrvision Pro\&. 
.PP
\fBParameters:\fP
.RS 4
\fIlocationID\fP Connection number 
.br
\fIprop\fP Camera property 
.br
\fIdeviceType\fP (2:D3D11, 0:OpenGL, -1:Dont share) 
.br
\fIpD3D11Device\fP ptr to D3D11 device when deviceType == 2 
.RE
.PP
\fBReturns:\fP
.RS 4
If successful, the return value is 0< 
.RE
.PP

.SS "void OVR::OvrvisionPro::PreStoreCamData (OVR::Camqt qt)"

.PP
This function gets data from \fBOvrvisionPro\fP inside\&. 
.PP
\fBParameters:\fP
.RS 4
\fIqt\fP Set an image processing method\&. 
.RE
.PP

.SS "void OVR::OvrvisionPro::SetCameraBLC (int value)"

.PP
Set backlight compensation(BLC) of the Ovrvision\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP BLC\&. Range of 0 - 255 
.RE
.PP

.SS "void OVR::OvrvisionPro::SetCameraExposure (int value)"

.PP
Set exposure of the Ovrvision\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Exposure time\&. Range of 0 - 32767 
.RE
.PP

.SS "void OVR::OvrvisionPro::SetCameraGain (int value)"

.PP
Set gain of the Ovrvision\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP gain\&. Range of 0 - 47 
.RE
.PP

.SS "void OVR::OvrvisionPro::SetCameraSyncMode (bool value)"

.PP
Set sync mode for the Ovrvision\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP True is sync mode\&. 
.RE
.PP

.SS "void OVR::OvrvisionPro::SetCameraWhiteBalanceAuto (bool value)"

.PP
Set automatic mode of the Ovrvision White Balance\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP Mode\&. 
.RE
.PP

.SS "void OVR::OvrvisionPro::SetCameraWhiteBalanceB (int value)"

.PP
Set white balance B gain of the Ovrvision\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP B gain\&. Range of 0 - 4095 
.RE
.PP

.SS "void OVR::OvrvisionPro::SetCameraWhiteBalanceG (int value)"

.PP
Set white balance G gain of the Ovrvision\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP G gain\&. Range of 0 - 4095 
.RE
.PP

.SS "void OVR::OvrvisionPro::SetCameraWhiteBalanceR (int value)"

.PP
Set white balance R gain of the Ovrvision\&. 
.PP
\fBParameters:\fP
.RS 4
\fIvalue\fP R gain\&. Range of 0 - 4095 
.RE
.PP

.SS "void OVR::OvrvisionPro::SetSkinHSV (int h_low, int h_high, int s_low, int s_high)"

.PP
set HSV region for SkinRegion 
.PP
\fBParameters:\fP
.RS 4
\fIh_low\fP (0 < h_low < h_high) 
.br
\fIh_high\fP (h_low < h_high < 180) 
.br
\fIs_low\fP (0 < s_low < s_high) 
.br
\fIs_high\fP (s_low < s_high < 256) 
.RE
.PP

.SS "void OVR::OvrvisionPro::SetSkinHSV (int range[4])"

.PP
set HSV region for SkinRegion 
.PP
\fBParameters:\fP
.RS 4
\fIrange[0]:h_low\fP (0 < h_low < h_high) 
.br
\fIrange[1]:h_high\fP (h_low < h_high < 180) 
.br
\fIrange[2]:s_low\fP (0 < s_low < s_high) 
.br
\fIrange[3]:s_high\fP (s_low < s_high < 256) 
.RE
.PP

.SS "\fBROI\fP OVR::OvrvisionPro::SetSkinScale (unsigned int scale)"

.PP
Set Skin image scale\&. 
.PP
\fBParameters:\fP
.RS 4
\fIscale\fP (2, 4, 8) of scale dominant 
.RE
.PP
\fBReturns:\fP
.RS 4
size of scaled image 
.RE
.PP

.SS "int OVR::OvrvisionPro::SetSkinThreshold (int threshold)"

.PP
set skin threshold to extract region 
.PP
\fBParameters:\fP
.RS 4
\fIthreshold\fP (0\&.\&.255) 
.RE
.PP
\fBReturns:\fP
.RS 4
previous threshold 
.RE
.PP

.SS "int OVR::OvrvisionPro::SkinRegion (unsigned char * left, unsigned char * right)"

.PP
Get skin color region\&. 
.PP
\fBParameters:\fP
.RS 4
\fIleft\fP image (MONOCHROME MASK) 
.br
\fIright\fP image (MONOCHROME MASK) 
.RE
.PP
\fBReturns:\fP
.RS 4
scale (2, 4) 
.RE
.PP

.SS "void OVR::OvrvisionPro::UpdateSkinTextures (unsigned int left, unsigned int right)"

.PP
Update skin textures\&. 
.PP
\fBParameters:\fP
.RS 4
\fIn\fP count of onjects 
.br
\fItextureObjects\fP 
.RE
.PP
/////////////////////////////////////////////////////////////////////////////////// Capture image and hold it only in GPU ovrvision\&.Capture(OVR::Camqt::OV_CAMQT_DMSRMP); Update textures ovrvision\&.UpdateSkinTextures(pTextures[0], pTextures[1]); /////////////////////////////////////////////////////////////////////////////////// 

.SH "Author"
.PP 
Generated automatically by Doxygen for OvrvisionSDK from the source code\&.
